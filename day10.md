# DAY 9

## --JAVA--

### ▷ 제네릭 (Generic)

- 클래스 내에서 사용되는 타입을 클래스가 정의할 때가 아닌 객체를 생성할 때 정의하겠다는 의미

- 하나의 코드를 다양한 타입의 객체에 재사용하는 객체 지향 기법

- 클래스, 인터페이스, 메서드를 정의할 때 타입을 변수로 사용

  - 장점 

    - 컴파일할 때 타입을 점검하기 때문에 실행 도중 발생할 오류를 미리 방지할 수 있음

    - 불필요한 타입 변환이 없어 프로그램 성능이 향상됨

      

**1. 제네릭 클래스와 인터페이스 **

- 타입을 변수로 사용하는 클래스와 인터페이스
- <>(다이아몬드연산자) 내부에 타입 매개변수를 표시
- 타입매개변수는 객체를 생성할 때 구체적인 타입으로 대체함
- 제네릭 클래스의 타입 매개변수는 필드나 메서드의 타입
- 타입매개변수 : 영문대문자면 어떤 것이 사용 가능
	- 일반 타입	   T  	type
	- 원소(요소) 	E	  element
	-  키		          K	  key
	-  숫자		      N	 number
	-  값		          V 	 value 

-  제네릭 클래스의 생성자
  - 제네릭클래스<적용할타입> 변수 = new 제네릭클래스<적용할타입>( );
  - 제네릭클래스<적용할타입> 변수 = new 제네릭클래스<>( );
- 기본타입(int, long, byte, boolean,...)은 사용할 수 없고, 참조 타입만 사용 가능

**2. 제네릭 상속 및 타입 한정**

- 자식 객체를 부모 타입 변수에 대입
- 타입 매개변수의 범위를 특정 타입으로 제한
	- < T extends 특정 클래스> 반환타입 메서드명(..){  }
	-  < T extends 인터페이스> 반환타입 메서드명(..){  }

**3. 제네릭 메서드**

- 제네릭 메서드는 제네릭 클래스뿐만 아니라 일반 클래스의 멤버도 될 수 있다.
 	- 일반 클래스에서 제네릭 메서드를 정의할 때는 타입 매개변수를 반환 타입 앞에 둠
		<- <타입매개변수> 반환타입 메서드명(..) {  }
  - 제네릭 메서드의 타입 매개변수는 메서드의 반환 타입이나 매개변수의 타입으로 사용할 수 있음
  - 제네릭 메서드를 호출할 때는 컴파일러가 매개변수 값의 타입을 보고 구체적인 타입을 추정할 수 있어 생략 가능

**4. compareTo (Object obj)**

- 값을 비교
  - 비교할 값이 매개값으로 받은 값보다 크면 : 1 을 반환
  - 비교할 값이 매개값으로 받은 값보다 작으면 : -1을 반환
  - 비교할 값이 매개값과 같으면 0을 반환

### ▷ 람다식(Lambda  Expression)

- 자바에서 함수적 프로그래밍을 지원하는 기법
- 코드의 간결화 및 병렬처리에 강함
- 자바에서 람다식은 함수적 인터페이스만 가능

**1. 함수적 프로그래밍**

- 기능만 전달하면 내부적으로 처리하겠다. (일반적 프로그램)
- 자바는 약간 다름, 이것을 자바에세 처리하게 하는 것이 람다식임

**\* 함수적인 인터페이스**

- 내부에 단 1개의 추상메서드만 존재하는 인터페이스
- 람다식의 타겟 타입이 될 수 있도록 함수적 인터페이스를 구현
- @FunctionalInterface 를 붙여주면 컴파일러가 추상메서드가 하나만 있는지 체크 
- 없거나 1개 이상이면 에러 발생 



**2. 람다식의 정의**

- 인터페이스의 구현 메서드 -> 람다식으로 변환



**3. 람다식의 적용방법 3가지**

- 익명이너클래스 내 구현 메서드의 약식 표현(람다식) => 내부에 한 개의 메서드만 포함한 인터페이스인 함수적 인터페이스만 가능

~~~
1) 익명이너클래스 내 구현 메서드의 약식 표현(람다식)=> 함수적 인터페이스만 가능

ex) LambdaInterface1 la = new LambdaInterface1() {
				
			@Override
			public void sum(int num) {
					System.out.println(num + 4);
				}
			};
			
			//lambda // 매개변수 타입 생략 가능 - 명확히 알 수 있을 때
			LambdaInterface1 la1 =(int num) -> {
					System.out.println(num + 4);
			};
			la1.sum(5);
			
			//lambda2  // 매개변수가 하나일 경우 () 생략 가능
			LambdaInterface1 la2 =num -> System.out.println(num + 4);
			la2.sum(5);
			
~~~



- 메서드 참조(인스턴스 메서드, 스택틱 메서드 참조)
  - 리턴타입과 매개변수가 동일해야 함
  - 클래스객체 :: 인스턴스메서드명
  - 클래스객체 :: 정적메서드명

~~~
ex)

	interface A{
			void abc();
		}

		class B{
			void bcd(){
			  	System.out.printl("메서드 참조 연습");
			}


	//익명이너클래스(익명이너인터페이스)
	 	A a = new A(){
			public void abc(){
				B b = new B();
				b.bcd();
			}			
		};
		a.abc();

	//람다식
		A a = () ->{
			B b = new B();
			b.bcd();
		};
		a.abc();

	// 메서드 - 클래스객체 :: 인스턴스메서드명
	 B b = new B();     
	 A a = b :: bcd;
	 
~~~



- 생성자 참조( 배열 생성자 참조, 클래스 생성자 참조)

~~~
ex)

interface A{
		void abc();
	}

	class B{
		static void bcd(){
		        System.out.printl(" 정적 메서드 참조 연습");
		}
	}

	//익명
	A  a = new A(){
		public void abc(){
	   		// B b = new B();  // 정적(static)메서드라 객체 생성 필요하지 않음
					// 정적메서드나 정적필드는 클래스이름.메서드명(), 클래스이름.필드명
			  B.bcd();
		}
	};		
	a.abc();

	// 람다
	 A a = () -> { B.bcd() };
	a.abc();

	// 메서드 참조 
		클래스명 :: 스태틱메서드명
	   
	  A a = B :: bcd;
	
	a.abc();
	
~~~



### ▷ 컬렉션 프레임웍 (Colletction Framework)

- collection  - 동일한 타입을 묶어서 관리하는 자료구조

  ​					 저장 공간의 크기(capacity)를 동적으로 관리 (추후 변경 가능(삽입, 삭제, 추가 가능)

- Framework - 클래스와 인터페이스를 모아 놓은 모임(라이브러리)
  		  	         클래스의 정의에 원칙 또는 구조 가 있음

-  배열 -동일한 타입만 묶어서 저장 , 생성시 크기를 지정하고, 추후에 변경 불가

  

  - java.util 패키지 안에 자료 구조를 라이브러를 제공	

- Collection interface - 하나의 자료를 모아서 관리하는 데 필요한 기능 제공

- List interface - 순차적인 자료를 관리하는 데 사용하는 클래스를 중복 허용하지 않음 (인덱스) 

- ArrayList 클래스 - 인덱스로 데이터 관리, 검색이 많을때 효과적

- Vector 클래스 - 용량 관리, 보안성 강화, 처리량 감소, 멀티스레드
- LikednList 클래스 - 추가/삭제가 많을 때 유리
- Set인터페이스  - 순서는 중요하지 않고, 중복을 허용하지 않는 클래스들 , 주머니(집합) / HashSet, TreeSet, ...
- Map 인터페이스 - 쌍(pair: key와 value)으로 된 자료들을 관리하는 데 유용한 기능을 제공 / HashMap, HashTable, TreeMap,...



1. **배열과 ArrayList**

   - 배열 - 길이에 제한을 두어야 할 때 자주 사용
   - ArrayList - 들어올 데이터 양을 알 수 없을 때, 데이터의 길이를 모를때

   

2. **List 컬렉션 객체 생성**

  - List<제네릭타입> 참조변수명 = new ArrayList<제네릭타입>();
  - List<제네릭타입> 참조변수명 = new Vector<제네릭타입>();
  - List<제네릭타입> 참조변수명 = new LinkedList<제네릭타입>();
                                                 또는
    ArrayList<제네릭타입> 참조변수명 = new ArrayList<제네릭타입>();
  - Vector<제네릭타입> 참조변수명 = new Vector<제네릭타입>();
  - LinkedList<제네릭타입> 참조변수명 = new LinkedList<제네릭타입>();

  

3. **주요 메서드**
   - add() : 추가
   - remove() : 제거
   - size() : 크기
   - clear() : 모두 제거
   - get() : 객체 가져오기
   - set()  : 변경