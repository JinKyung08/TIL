# DAY 06

## --JAVA--

### ▷ 객체지향

**1. 객체지향 프로그래밍 OOP(Object Oriented Programming)**

 변수 ->  배열 -> 구조체 -> 클래스(기능 추가 - 상속,메서드....,java)

- 절차 지향형 (기능중심) 프로그램 : 순서에 맞춰 단계적으로 실행하도록 명령을 나열
- 객체지향형 (객체중심) 프로그램 : 객체를 구성하고 객체 단위로 프로그래밍(필드/메서드)

**\* OOP(Object Oriented Programming)**

- 객체 지향 프로그래밍의 특징

  - 캡슐화(Encapsulation) /정보은닉 : 객체의 필드(멤버변수), 메소드를 하나로 묶고,실제 구현하는 내용을 감추는 것

    ​		       접근 제한자를 사용해서 접근을 처리

    ​			 - 접근 제한자 : 객체의 필드와 메소드의 사용 법위를 제한함으로써 외부로부터 보호하는 역할

  - 상속 ( Inheritance) : 재사용성

     ​              상위 객체를 재사용해서 하위 객체를 쉽고 빠르게 설계할 수 있도록 도와줌
  
    ​	          이미 잘 개발된 객체를 재사용해서 새로운 객체를 만들기 때문에 반복된 코드의 중복을 줄여줌
  
  - 다형성(Polymorphism) : 같은 타입이지만 실행 결과가 다양한 객체를 이용 할 수  있는 성질 ​  ​			             
  
       ​             자바 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용
  
  ​			         다형성의 효과는 객체의 부품화가 가능



### ▷ 클래스

**1.클래스 구성요소**

- 클래스 멤버
  - 필드 (field = 클래스 멤버 변수, 멤버변수)
    - 객체의 데이터가 저장되는 곳, 상태정보(이름,나이,색상,...)
  - 메서드 (method)
    - 객체의 동작에 해당하는 실행 블록 { }
    - 리턴타입 메서드명 ( ) { }
    - 객체 간의 데이터 전달 할 때 사용
    - 외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴(반환)할 수도 있음

- 생성자 ( Constructor)
  - 객체 생성 시 초기화 역할 담담
  - 객체를 사용할 준비
  - 리터 타입 X
  - 클래스명과 같다. 클래스명 () {}

- 이너클래스

클래스의 용도 : 라이브러리(API:Application Program interface) - 다른 클래스에서 이용할 목적

실행용 - 프로그램을 실행할 진입점인 main()메소드를 제공하는 역할



**2. 클래스 만들기**

클래스 만들기 (설계도, 틀, 구조) -> 객체(인스턴스)생성 -> 객체 사용

- 클래스 만들기

  - 접근제한자 class 클래스명{

    ​					필드

    ​					생성자

    ​					메서드

    ​					이너클래스

    }

\* 주의사항 : public class 키워드는 클래스를 선언할 때 사용하며 반드시 소문자로 작성

​					클래스 이름 뒤에는 반드시 중괄호 {} 를 붙여준다.

​					public class Student {  }

​					소스파일은 클래스 선언을 담고 있는 저장 단위일 뿐 클래스 자체가 아님.

​					** 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙임.



**3. 객체만들기**

- new 연산자 : 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴

  ​                       참조타입 변수(클래스 변수)에 저장

  - 클래스명 참조변수명;

    참조변수명 = new 클래스명();

- 생성자 : new 연산자와 같이 사용되며 클래스로부터 객체를 생성할 때 호출되어 초기화를 담당

  객체초기화 - 필드를 초기화하거나, 메서드를 호출해서 객체를 사용할 준비를 하는 것

  생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없음

  힙영역에 객체를 생성하고 주소를 리턴

  

  - 기본 생성자

    - [public] 클래스( ){ }

  - 생성자 선언

    - [public] 클래스(매개변수선언,...){

      //객체의 초기화 코드

      }

- 필드 선언

  - 클래스 중괄호 안에 위치, 클래스 내에서 어디서든 사용할 수 있음

  - 힙영역의 객체안에 위치 (인스턴스 필드)

  - 초기화 하지 X  -> 컴파일러가 기본값으로 자동 초기화

    - 지역변수 -  메서드, 생성자의 중괄호 안에 선언

      ​					메서드가 종료되면 메모리에서 사라짐

      ​					스택 지역변수는 자동 초기화 X 선언시 초기화시킨다.

  - 초기화 - 접근제한자 타입형 필드명 = 값 ; //모든객체가 같은 값으로 초기화

    ​				생성자를 이용해서 초기화

  - 필드 사용 범위

    - 클래스 내부에서 모두 사용가능 (생성자,메서드)

    - 클래스 외부에서 사용 -> 반드시 객채 생성 후 필드 사용

      \* 필드는 객체 소속 데이터 ,객체가 존재 X -> 필드도 존재 X

### ▷ 메서드(method)

- header 와 body 로 구성

- 객체의 동작에 해당하는 {} 블록

- 메서드를 호출 => 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행

- 객체 간의 데이터 전달의 수단으로 사용

- 외부로부터 매개값을 받을 수 있고 실행 후 어떤 값을 리턴 할 수도 있음

- 중복코드를 줄이고 코드를 재사용 할 수 있음

- 코드의 모듈화를 통해 코드의 가독성을 ↑

  

(1) 메서드 선언

- 리턴타입 메서드이름(매개변수,..) { //body

  ​	실행할 코드 작성

  }

  - 메서드 시그니처 : 선언부 (리턴타입,메서드이름,매개변수 선언)와 {}

    접근지정자 static 리턴타입 메서드이름 (매개변수,... ) {//body

    ​	실생할 코드 작성

    }

  - 접근지정자 : 컴파일러에게 메서드의 접근 범위 알려줌

  - static : 객체를 생성X, 실행 O

(2) 메서드 정의할 때 고려 사항

- 리턴되는 값이 X 리턴 타입 - void

- 리턴되는 값이 O - 해당 리턴값의 자료형(int, String, double,...)

- 메서드를 외부에서 호출하는 경우 - 참조 객체를 만들고 호출

- static 메서드를 외부에서 호출하는 경우 - 클래스명.메서드명()

  객체를 생성하지 않고 클래스명을 통해 바로 호출

- 메서를 내부에서 호출하는 경우 - 메서드 이름으로 바로 호출



(3) 메서드 오버로딩(overloading)

- 하나의 메서드로 여러 기능을 구현하기 때문에 붙여진 이름

- 오버로딩의 조건 - 메서드 이름은 같고 매개변수의 데이터 타입, 개수, 순서 중 하나가 달라야한다.

  - 단, 리턴타입은 의미X

    리턴타입만 다르고 매개변수가 동일하다면 오버로딩 X

    컴파일러는 매개값의 타입을 가지고 메서드를 찾기 때문

	```class MethodOverloading{
	public int add(int x, int y) {
		return x + y ;
	}
	
	
	public int add(int x, int y , int z) {
		return x + y + z ;		
	}
	
	public double add(double dx, int y ) {
		return dx + y ;		
	}
	
	public double add(int x, double dx ) {
		return x + dx ;
	}
	
	public double add(double dx, double dy ) {
		return dx + dy ;		
	}
	
	}


### ▷ static (정적)

**1.static(정적) 멤버(메서드,필드)**

* 정적 / 고정된 이란 의미
* 정적멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드 와 메서드
* 클래스에 소속된 멤버로 객체 내부에 존재 X,  메서드 영역에 존재
* 객체를 생성하지 않고 클래스로 바로 접근해서 사용
* 고용적인 테이터로 처리 하고 싶을 때 사용



**2.정적멤버 선언(static 멤버)**

* 클래스로 관리 , 클래스가 로딩되면 바로 사용할 수 있다.

  * public class 클래스명{

    ​	static 자료형 필드명;

    ​	static 자료형 필드명=값;

    

    ​	static 리턴타입 메서드명( ){ }

    // 인스턴스 멤버 : 반드시 객체를 생성해야 사용할 수 있다.

    ​	자료형 필드명;

    ​	자료형 필드명 = 값;

    

    ​	리턴타입 메서드명 ( ){ }

    }



**3. 정적 멤버 사용(static 멤버(필드,메서드))**

- 클래스명. 필드명

  클래스명.메서드명()



**4. 정적 초기화 블록**

* 인스턴스 필드는 생성자에 의해서 초기화됨
* static은 객체를 생성하지 않기 때문에 따로 초기화 블록 설정

​          static{

​          			초기화 시킬 값

​          }

* static블럭은 클래스가 메모리로 로딩될 때 자동으로 실행
* 클래스가 메모리로 로딩될 때 선언된 순서대로 실행 하기 때문에 클래스 내부에 여러개가 선언되어도 상관 없다.



**5. static 메서드와 블록 선언시 주의사항**

* static메서드 안에는 인스턴스 필드,메서드 사용 X -> 인서턴스는 객체가 생성되어야만 만들어지기 때문에
* 객체 자신의 참조인 this 키워드 사용 X
* 정적 메서드와 정적 블록에서 인스턴스 멤버를 사용하려면 객체를 먼저 생성하고 참조 변수로 접근해야 한다. 

### ▷ 생성자

**1. 생성자(constructor)**

- new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당

  * 객체의 초기화 - 필드를 초기화 ,메서드를 호출해서 객체를 사용할 준비를 하는 것

- 생성자를 실행X -> 클래스로부터 객체를 만들 수 X

- 모든 클래스는 생성자가 반드시 존재 (하나 이상)

- 클래스 내부에 생성자 선언은 생략하면 컴파일러가 기본 생성자를 내부적으로 생성해서 실행한다.

- 생성자는 리턴 타입이 없고 클래스 이름과 동일

- 기본생성자 : 클래스명(){}

- 생성자 선언 : 클래스명(매개변수,..){ 

  ​										객체의 초기화 코드 작성

  ​                        }

  * 매개변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블로 내부로 전달 하는 역할

- 클래스에 생성자가 명시적으로 선언되어 있을 경우 반드시 선언된 생성자를 호출해서 객체를 생성



**2. 생성자 오버로딩**

* 매개변수를 달리하는 생성자를 여러 개 선언하는 것

* 매개변수의 타입, 개수, 순서가 다르게 선언

  * this 

    - 객체 자신을 참조
    - 자신의 번지를 가지고 있음
    - 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 프리드임을 명시하고자 할 때 사용

  * this()

    - 다른 생성자 호출

    - 오버로딩이 많아 질 경우 생성자 간의 중복된 코드 발생할 수 있음

       -> 필드 초기화 내용은 한 생성자에만 집중적으로 작성,

      ​	나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출

    - this()는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에만 허용

