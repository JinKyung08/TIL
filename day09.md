# DAY 9

## --JAVA--

### ▷ 추상클래스 (abstract class)

- 추상 메서드를 포함한 클래스

  - 추상메서드 - 본체가 정의되어 있지 않은 미완성 클래스

    ex) abstract void showInfo () **; **-> 추상클래스

  \* 메서의 완성과 미완성은 중괄호{}가 있느냐 없느냐의 차이

  - 접근제한자 abstract class 클래스명 {

  ​				미완성된 추상메서드 포함

  ​        }     

  ​	    ex) abstract class Vehicle {

  ​        				String name = "탈것";

  ​						void kind () ; ->추상메서드 

  ​						void move() { }->완성된 메서드

  ​              }

- 상속을 통해 자식클래스에서 추상메서드를 **오버라이딩**해서 완성

- 추상클래스의 필요성

  - 추상메서드를 상속받은 자식은 반드시 **오버라이딩**을 해야만 오류가 없어지고 객체 생성도 가능 

  - 추상메서드는 자식이 오버라이딩을 하지 않으면 오류 발생 반드시 오버라이딩을 해야함 

    -> 오버라이딩을 빼놓는 실수를 하지 않음

  - 추상클래스를 사용하면 자식클래스가 반드시 오버라이딩했다는 것을 보장할 수 있음

- 추상클래스의 특징

  - 객체 생성 할 수 X -> 추상메서드를 포함하므로 heap메모리에 완성되지 않은 것을 올릴 수 없기 때문
  - 익명이너클래스를 사용하면 컴파일러가 내부적으로 클래스를 생성한 후 메서드 오버라이딩을 수행
    - 클래스 이름 알 수 없고 클래스 안에 생성 되어 익명이너클래스라고 함

- 익명이너 클래스 

  - 한 번만 사용하는 클래스라면 굳이 이름을 붙일 필요가 없음 ->이름이 없는 클래스를 익명클래스(anonymous class)

  - 중첩클래스(내부클래스)의 특수한 형태로 코드가 단순해지기 때문에 이벤트 처리나 스레드등에서 자주 활용

  - 

    

\* 상속을 통한 구현과 익명이너클래스 사용의 장점과 단점

  		1. 추상 클래스를 일반 클래스로 상속하여 객체 생성
       - 객체 여러개 생성 가능
       - 객체는 클래스 이름만 알면 몇 개건 만들 수 있음
       - 클래스를 만들어야 해서 조금 복잡
       - 객체를 여러개 만들고자 할 때 좋음
  		2. 익명이너클래스 사용
       - 클래스를 모르기 때문에 객체를 만들때마다 구현부분을 다 작성해야 함
       - 딱 한번만 쓸 거라면 익명이 좋음 (주로 이벤트 처리에 좋음)
       - 객체를 한번만 쓸 때 유리

### ▷ 인터페이스 (interface)

- 모든 필드가  public static final로 정의 , 생략-> 컴파일러가 자동으로 컴파일 추가함
- 모든 메서드가 public abstract로 정의 , 생략 -> 컴파일러가 자동으로 컴파일 추가함
  - 단, default 메서드 제외
- 추상클래스와 차이점 - 인터페이스는 모두가 추상메서드

~~~
public interface 인터페이스명{
	   
	   //*필드
	**  public static final 필드명 =값;
	   
	   //**메서드
	*** public abstract 리턴타입 메서드명(매개변수,..); //추상메서드
	   
	   //default 메서드 - 추상 X
	    public default 리턴타입 메서드명 (매개변수,..){} // body구현, 자바1.8(8버전)부터추가
	   
	   //static 메서드 - 추상 X
	    public static 리턴타입 메서드명 (매개변수,..){} // body구현, 자바1.8부터 추가
	   
	   //비공개 메서드 -추상 X
	    private 리턴타입 메서드명 (매개변수,..){} // 자바9부터 선언가능, 인터페이스 내부에서만 사용할 수 있는 일종의 도우미 메서드 
}
~~~



- 인터페이스의 상속

  - implements 사용

  - 다중 상속(구현)이 가능

    - 인터페이스 -> 인터페이스 / 구현 X
    - 인터페이스 -> 인터페이스 / 상속 가능

    ~~~
     ex)
     interface A { ... } 
     interface B { ... }
     class C{...}
     class D{...}
     
     //가능
     class C implements A {}
     class C implements A,B{}
     interface A extends B{}
     class D extends C implements A,B{} 
     
     //불가능
     class C extends A {}
     class C extends A,B {}
     interface A implements B {}
    ~~~

- 어댑터 클래스

  - 자식이 필요로 하지 않는 것을 구현하고 자식이 필요하는 것은 추상으로 남겨줌

### ▷ String 참조 자료형

**1.String 클래스**

- 클래스(class, 설계도,틀), 객체 - 클래스로 만들어낸 실체
- 문자열 저장 클래스 타입
- 문자열 큰따옴표 " " 안에 표기



(1) String 객체 생성

- String 참조 변수명 = new String("문자열"); // String() 생성자 - 출력은 객체 (String() 생성자를 통해 객체를 만드고 그것은 힙에 넣어줌)
- String 참조변수명 = "문자열"; // 값 - 리터럴 

~~~~
        String name1 = "홍길동";
		String name2 = "홍길동";
		String name3 = new String("홍길동");
		
		System.out.println(name1==name2);  // true == 스택안에 있는 변수에 담긴 값이 같은가?
		System.out.println(name1==name3);  // false
		System.out.println(name2==name3);  // false
		
		
		//참조변수가 가리키는 내용이 같은가 // 글자가 같은가?
		System.out.println(name1.equals(name2)); // true
		System.out.println(name1.equals(name3)); // true
		System.out.println(name2.equals(name3)); // true
		
~~~~



(2) String 클래스만 가지고 있는 2가지 특징

- 객체 내의 값 변경 불가능 -> 값 변경시 새로운 객체를 생성하여 작성
- 리터럴을 바로 입력한 데이터는 문자열이 같은 경우 하나의 객체를 공유

- String 객체의 '+' 연산
  - 문자열 + 문자열 ->  문자열을 연결
  - 문자열 + 기본자료형 or 기본자료형 +문자열 -> 기본자료형을 문자열로 변환 + 문자열 연결
  - String.valueof(값) - String 으로 변환
    - String.valueof(기본자료형) -> 기본자료형을 String으로 변환
- String의 주요 메서드
  - 문자열 길이 (length) :문자열.length()
  - 문자열 검색(charAt, indexOf, lastIndexOf)
    - 문자열.charAt(인덱스) : 인덱스 위치의 문자
    - 문자열.indexOf(찾는 문자) : 문자 위치의 인덱스
    - 문자열.lastIndexOf(찾는 문자) : 뒤에서부터 일치하는 문자 위치의 인덱스
    - 문자열1.concat(문자열2) : 문자열 연결

### ▷ 예외 (Exception)

- Exception : 개발자가 해결 가능한 오류 ( 대체 방안을 만들어서 해결)  - 연산오류, 포맷 오류,...
- Error : jvm 자체의 오류로 개발자가 해결할 수 없음  - 메모리부족, 스레드 문제,...

1. Exception의 종류
    *   일반예외 : 문법체크, 컴파일 자체가 불가능(빨간줄..)   ex) System.out.println("가나);
    *   실행예외 : 문법체크 X , 예외가 발생되면 프로그램이 종료. 예외메시지 출력  ex) System.out.println(7/0); /by zero

2. 구문 

~~~
   try {
		 예외가 발생할 가능성이 있는 구문
 		}catch (예외종류 참조변수){
 			 예외가 발생할 때 실행할 문장
  		}catch (예외종류 참조변수){
 			 예외가 발생할 때 실행할 문장
 		}...catch (예외종류 참조변수){
 			 예외가 발생할 때 실행할 문장
  		}
 
    try{
  		  예외가 발생할 가능성이 있는 구문
 		}catch (예외종류 참조변수){
  			예외가 발생할 때 실행할 문장
 		}finally{
 			 예외가 발생하든 발생하지 않든 실행할 문장
 		}
~~~

- 예외가 발생할 수 있는 경우들을 catch문을 이용해 선언
- 계발단계에서 확인용으로만 사용하고 개발 끝나면 반드시 주석처리 또는 제거 
- 제거를 하지 않으면 보안 위험이 생김



3. 리소스 자동해제 예외처리 (try with resource) :
   - java에서 많이 사용

~~~
     try(리소스를 사용하는 코드){
 			//리소스를 사용하지 않는 예외발생 가능 코드
 	 } catch(예외클래스명 참조병수명){
 			//해당예외가 발생할 경우 처리 블록
 	 }finally{
 			//예외와 상관없이 무조건 실행
 	 }
~~~



4. 예외 전가(throws)
   - 예외처리를 자신이 호출된 지점으로 전가, 이 경우 예외처리는 전가 받은 상위 위치에서 처리

~~~
메서드명(매개변수... ) throws 예외클래스
리턴타입 매서드명(매개변수...) throws 예외클래스 
~~~

