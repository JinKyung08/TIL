# DAY 7

## --JAVA--

### ▷ 패키지

- 비슷한 목적으로 생성된 클래스 파일들을 한 곳에 모아 둔 폴더
- 프로젝의 하위 폴더
- 클래스 이름의 충돌 방지 (패키지마다 다른 이름의 공간을 만들기 위해 패키지 사용)
- 반드시 첫 줄에 표시
- 목적별로 묶어서 관리
  - java. lang  - 자바의 가장 기본적인 클래스 묶음
  - java.util  - 유용한 확장 클래스 묶음
  - java.io - 자바의 입출력 패키지 관련 클래스



### ▷ import

- import 패키지명.클래스명;

- 다른 패키지의 클래스를 사용하고자 할 때

  - import 하지 않은 경우 - abc.bcd.efg.A a = new abc.bcd.efg.A ()

  - import 사용하는 경우 - import abc.bcd.efg.A;

    ​										 A a = new A();

- 패키지가 다른 동일 한 이름의 클래스는 두 개 이상 import X

  -> 풀네임 사용

- 접근제한자가 public이어야 다른 패키지에서 import 가능

- 패키지 안의 모든 클래스를 한번 import하기 위해서 * 를 사용함

  - 단, 패키지는 import X

    import abc.def.A;

    import abc.def.B;

    import abc.def.C;  

    -> import abc.def.*;

### ▷ 접근 제어자 (modifier)

- 반드시 설정 해야함.
- class : public, default (=package)
- 필드,메서드, 생성자 : public, protected, default, private
  - public - 모든 클래스 사용 가능 (같은 + 다른 패키지)
  - protected - 같은 패키지에 있는 클래스에서는 모두 사용가능 , 다른 패키지는 자식 클래스에서만 사용가능
  - default - 접근제어자가 생략 -> default, 같은 패키지에 있는 클래스 안에서 자유롭게 사용가능 / 다른 패키지에서 사용 X
  - private - 같은 클래스 안에서만 자유롭게 사용 가능
    - 캡슐화, 데이터 은닉
    - 외부에서 접근하려면 getter, setter 메서드를 이용해서 접근

### ▷ getter/setter

- 데이터는 외부에서 접근 할 수 없도록 막고 getter와 setter메서드는 공개해서 외부에서 메서드를 통해 테이터에 접근하도록 유도

- 메서드는 매개값을 검증해서 유효한 값만 데이터로 저장 하거나 내보낼 수 있음

- 앞에 get 또는 set을 쓰고 바로 뒤에 필드명의 첫 글자를 대문자로 처리

  ex) getColor, setColor

  ​		boolean 은 is 뒤에 필드명을 붙인다. isMaxSpeed

- Alt+Shift+S - Generate Getters and Setters



### ▷ 상속(Inheritance)

- **접근제어자 class 자식클래스 extends 부모클래스{}**

- 기존 클래스를 재사용하여 새로운 클래스를 작성하는 것

- 코드를 공통적으로 관리 -> 코드 추가 및 변경 쉬움

- 코드의 재사용성 ↑, 중복을 제거

- 다중상속 지원 X , 단일 상속만 가능

  - class 자식클래스 extends 부모클래스1, 부모클래스2,...{} X
  - class 자식클래스 extends 부모클래스{} O

- 부모 = 조상 = 상위(super) = 기반(base) 클래스

  자식 = 자손 = 하위(sub) = 파생된 클래스

- jvm은 자식 클래스의 객체를 생성할 때 부모 클래스의 객체를 생성 한 후 자식 클래에서 추가한 필드와 메서드를 객체에 추가

- 자식 클래스는 부모 클래스에서 물려받은 멤버를 그대로 사용 하거나 변경(오버라이딩=재정의) 할 수 있고 새로운 멤버도 추가 가능

- 상속 X

  - 부모 클래스에서 private접근 제한을 갖은 필드와 메소드
  -  생성자, static멤버
  - 부모 클래스와 자식 클래스가 다른 패키지에 존재 한다면 default 접근제한을 갖는 필드와 메소드



### ▷ 메서드 오버라이딩 (Method Overriding)

* 부모 클래스에서 상속받은 메서드와 동일한 이름의 메서드를 재정의 하는것
* 물려 받은 부모메서드를 자식 클래스에 맞도록 수정 하는 것 

1. 규칙
   - 부모 클래스의 메서와 동일한 시그니처(메서드명, 매개타입, 매개변수 개수 ,순서)를 사용
   - 리턴타입까지 동일해야 함
   - 부모클래스의 메서드보다 접근제한자 범위를 더 좁게 할 수 X
2. 오버라이딩 불가능한 경우
   * private 메서드 : 상속X
   * static 메서드 : static은 클래스 안에 존재
   * final 메서드 : final은 수정 X -> 재정의 X
3. @ - 어노테이션
   - 오버라이딩 된 메서드 위에 @Override를 붙여줌
     - 인스턴스필드와 정적멤버는 자식 클래스에서 동일한 이름으로 정의해도 오버라이딩 X
       - 인스턴스필드는 객체 내에, 정적멤버는 클래스 내부에 존재하여 저장 공간이 완전히 분리 되어있어 오버라이딩 X
       - 인스턴스 메서드는 객체 내의 메서드 위치를 저장하는 공간은 분리 되어 있지만 실제 메서드가 정장되는 공간은 인스턴스 메서드 영역 한곳이므로 오버라이딩이 발생함
       - 동일한 필드나 메서드가 있을 때 참조 변수가 가리키는 객체의 바깥쪽부터 안쪽으로 들어가면서 만나는 첫 번째 멤버가 실행 

- class A {                                

  ​            void show(){

  ​                       System.out.println("A클래스")            

  ​        }

  }

- class B extends A{

  ​           @override

  ​			void show(){

  ​                    System.out.println("B클래스")

  ​       }

   }

4. super 키워드와 super() 메서드

   - super : 부모의 객체

     this : 자신의 객체

   - super() : 부모의 생성자

     this : 자신의 생성자

     - 반드시 생성자의 첫 줄에 위치, 생략시 컴파일러가 자동 삽입

### ▷ 다형성(Polymorphism)

- 1개의 객체를 여러 가지 모양으로 표현할 수 있는 특성

​		/ 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질

- 부모 타입에 모든 자식객체가 대입될 수 있다. (자식타입 -> 부모타입 자동 타입변환 가능)

1. 객체의 타입(형)변환
   - 상속 관계일 때만 가능
   - 자동 타입(형)변환, 강제 타입(형) 변환이 있음

- 업캐스팅 : 기본자료형 - 범위가 좁은 쪽에서 넓은 쪽으로 

​						 객체 - 자식 클래스에서 부모 클래스 쪽으로 변환되는 것

​						 객체는 항상 업캐스팅할 수 있으므로 명시적으로 적어 주지 않아도 컴파일러가 대신 넣어줌

- 다운 캐스팅 : 다운 캐스팅은 개발자가 직접 넣어 주어야 함

- 캐스팅 가능 여부
  - 어떤 생성자로 생성됐는지 '중요' / 무슨 타입 ->중요X
  - 힙 메모리 내에 해당 객체가 있어야 함

2. 자동 타입(형) 변환

   - 자식 클래스를 부모 클래스로 타입을 변환할 수 있음(up casting, upcast)

   - 변환연산자 (타입)가 없이 자식 클래스를 부모 클래스로 변환하는 것

     - Animal ani = new Cat(); 

       ​		(Animal ani =(Animal) new Cat();)

     - Cat cat = new Cat(); 

       Animal ani = cat; 

       ​			(Animal ani = (Animal)cat;)

   - 자동 타입 변환은 부모 타입 변수로 자식 객체에 접근가능

   - 부모 타입 변수로 부모 타입에 있는 자식 멤버에 접근가능, 자식타입에만 있는 자식 멤버에는 접근 X

3. 강제 타입(형) 변환

   - 부모 타입 객체 -> 자식 타입 으로 변환 X /오류발생
   - 자식 객체이지만 부모 타입 변수가 참조하고 있다면 자식 타입으로 변환할 수 있음 (down cast)

4. 타입 변환 가능 확인

   - instanceof

     - 변수 instanceof타입

       변수가 타입으로 변환 O -> true, 변환X -> false

       변수가 해당 타입과 관련 X -> 오류발생

     - 참조변수 instanceof 타입

       true - 참조변수가 해당 타입으로 캐스팅 가능

       false - 참조변수가 해당 타입으로 캐스팅 불가능

5. 타입 변환을 이용한 다형성

   - 다형성 : 하나의 참조 변수에 여러 객체를 대입해서 다양한 동작을 수행하도록 하는 것 
   - 다양한 객체에 동일한 명령어를 적용해, 객체의 종류에 따라서 다양한 동작을 얻을 수 있음
   - 자식 객체를 부모 타입 변수에 대입하면 부모 클래스에 선언된 멤버(필드, 메서드)만 볼 수 있음
   - 부모 클래스에 선언된 메서드를 자식 클래스가 오버라이딩 -> 부모 타입 변수에 부모 객체의 메서드는 보이지 X, 자식 객체의 메서드만 보임
     * jvm이 실행단계에서 객체의 실제 타입을 보고 오버라이딩한 메서드를 호출하기 때문에

\* 부모 클래스의 필드(객체안)와 정적 메서드(클래스안에)는 오버라이딩될 수 없다.